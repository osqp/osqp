import"./_Uint8Array-CPNtPV0k.js";import"./isSymbol-D1Vf4s0g.js";import"./_arrayMap-DQI2GUNb.js";import"./toString-pPvo2488.js";import"./toNumber-Bjr00yqN.js";import"./toInteger-Qi6pclEF.js";import"./isArrayLikeObject-CQy5-FN4.js";import"./_getTag-C4fv2peH.js";import{r as S}from"./_baseUniq-DuMeVp_r.js";import"./_baseIsEqual-Cdnsi4t8.js";import"./_toKey-BvVjBIlz.js";import"./memoize-D2QB0zzX.js";import"./get-Bi1nZ6vb.js";import"./_baseFlatten-BM8p5vhd.js";import"./_basePickBy-CViVNfOD.js";import"./pick-CHglt4eJ.js";import"./merge-DrdmtLTL.js";import"./_hasUnicode-CPHpt5EV.js";import"./_arrayReduce-DDpPg0Qh.js";import{t as F}from"./clone-C-4MVcJh.js";import{t as L}from"./dagre-CUW-rZ9o.js";import"./_baseEach-CWBhny_f.js";import"./hasIn-BZo8Xaqq.js";import"./_baseProperty-CIKnF2iY.js";import"./now-CKgsywea.js";import{o as D}from"./min-DZ9NrTCT.js";import"./_baseMap-vZ8RB515.js";import"./isEmpty-D1b_MAwx.js";import"./_baseSet-B-t_O9-N.js";import"./sortBy-DV7a6-en.js";import"./range-Dsq9WHSI.js";import{t as O}from"./graphlib-C6T8v0kT.js";import"./preload-helper-DImqtvgl.js";import"./marked.esm-C_54K2ke.js";import"./timer-m_pEB4Lb.js";import"./src--EmJf_Ct.js";import"./path-Gc-fQZTe.js";import"./math-BsaXoFIn.js";import"./array-DZFD9yN1.js";import"./step-aJ-oEw6-.js";import"./line-1VYCafWO.js";import"./chunk-S3R3BYOJ-Dy72CLbv.js";import{n as w,r as i}from"./src-CWnjMQt8.js";import{b as M}from"./chunk-ABZYJK2D-eZsthrBr.js";import"./chunk-7GE3RBXV-DqGwDDxD.js";import{t as j}from"./chunk-CVBHYZKI-Bv-w4YHJ.js";import"./chunk-QYVHNE3D-BxN3DJBX.js";import"./dist-D2dAPhhG.js";import"./chunk-JA3XYJ7Z-pR89xWsn.js";import{a as Y,c as k,i as H,l as _,n as z,t as q,u as K}from"./chunk-CXMOBAN2-DxbPW6zT.js";import{a as Q,i as U,n as V,r as W,t as Z}from"./chunk-3AY6CYHV-CBq2x1Nc.js";function X(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:$(e),edges:ee(e)};return S(e.graph())||(n.value=F(e.graph())),n}function $(e){return D(e.nodes(),function(n){var r=e.node(n),o=e.parent(n),l={v:n};return S(r)||(l.value=r),S(o)||(l.parent=o),l})}function ee(e){return D(e.edges(),function(n){var r=e.edge(n),o={v:n.v,w:n.w};return S(n.name)||(o.name=n.name),S(r)||(o.value=r),o})}var c=new Map,b=new Map,G=new Map,re=w(()=>{b.clear(),G.clear(),c.clear()},"clear"),I=w((e,n)=>{let r=b.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",r.includes(e)),r.includes(e)},"isDescendant"),ne=w((e,n)=>{let r=b.get(n)||[];return i.info("Descendants of ",n," is ",r),i.info("Edge is ",e),e.v===n||e.w===n?!1:r?r.includes(e.v)||I(e.v,n)||I(e.w,n)||r.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),P=w((e,n,r,o)=>{i.warn("Copying children of ",e,"root",o,"data",n.node(e),o);let l=n.children(e)||[];e!==o&&l.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",l),l.forEach(s=>{if(n.children(s).length>0)P(s,n,r,o);else{let a=n.node(s);i.info("cp ",s," to ",o," with parent ",e),r.setNode(s,a),o!==n.parent(s)&&(i.warn("Setting parent",s,n.parent(s)),r.setParent(s,n.parent(s))),e!==o&&s!==e?(i.debug("Setting parent",s,e),r.setParent(s,e)):(i.info("In copy ",e,"root",o,"data",n.node(e),o),i.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==o,"node!==clusterId",s!==e));let d=n.edges(s);i.debug("Copying Edges",d),d.forEach(p=>{i.info("Edge",p);let E=n.edge(p.v,p.w,p.name);i.info("Edge data",E,o);try{ne(p,o)?(i.info("Copying as ",p.v,p.w,E,p.name),r.setEdge(p.v,p.w,E,p.name),i.info("newGraph edges ",r.edges(),r.edge(r.edges()[0]))):i.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",o," clusterId:",e)}catch(N){i.error(N)}})}i.debug("Removing node",s),n.removeNode(s)})},"copy"),B=w((e,n)=>{let r=n.children(e),o=[...r];for(let l of r)G.set(l,e),o=[...o,...B(l,n)];return o},"extractDescendants"),te=w((e,n,r)=>{let o=e.edges().filter(d=>d.v===n||d.w===n),l=e.edges().filter(d=>d.v===r||d.w===r),s=o.map(d=>({v:d.v===n?r:d.v,w:d.w===n?n:d.w})),a=l.map(d=>({v:d.v,w:d.w}));return s.filter(d=>a.some(p=>d.v===p.v&&d.w===p.w))},"findCommonEdges"),x=w((e,n,r)=>{let o=n.children(e);if(i.trace("Searching children of id ",e,o),o.length<1)return e;let l;for(let s of o){let a=x(s,n,r),d=te(n,r,a);if(a)if(d.length>0)l=a;else return a}return l},"findNonClusterChild"),T=w(e=>!c.has(e)||!c.get(e).externalConnections?e:c.has(e)?c.get(e).id:e,"getAnchorId"),ie=w((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(r){e.children(r).length>0&&(i.warn("Cluster identified",r," Replacement id in edges: ",x(r,e,r)),b.set(r,B(r,e)),c.set(r,{id:x(r,e,r),clusterData:e.node(r)}))}),e.nodes().forEach(function(r){let o=e.children(r),l=e.edges();o.length>0?(i.debug("Cluster identified",r,b),l.forEach(s=>{let a=I(s.v,r),d=I(s.w,r);a^d&&(i.warn("Edge: ",s," leaves cluster ",r),i.warn("Descendants of XXX ",r,": ",b.get(r)),c.get(r).externalConnections=!0)})):i.debug("Not a cluster ",r,b)});for(let r of c.keys()){let o=c.get(r).id,l=e.parent(o);l!==r&&c.has(l)&&!c.get(l).externalConnections&&(c.get(r).id=l)}e.edges().forEach(function(r){let o=e.edge(r);i.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),i.warn("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(e.edge(r)));let l=r.v,s=r.w;if(i.warn("Fix XXX",c,"ids:",r.v,r.w,"Translating: ",c.get(r.v)," --- ",c.get(r.w)),c.get(r.v)||c.get(r.w)){if(i.warn("Fixing and trying - removing XXX",r.v,r.w,r.name),l=T(r.v),s=T(r.w),e.removeEdge(r.v,r.w,r.name),l!==r.v){let a=e.parent(l);c.get(a).externalConnections=!0,o.fromCluster=r.v}if(s!==r.w){let a=e.parent(s);c.get(a).externalConnections=!0,o.toCluster=r.w}i.warn("Fix Replacing with XXX",l,s,r.name),e.setEdge(l,s,o,r.name)}}),i.warn("Adjusted Graph",X(e)),A(e,0),i.trace(c)},"adjustClustersAndEdges"),A=w((e,n)=>{var l,s;if(i.warn("extractor - ",n,X(e),e.children("D")),n>10){i.error("Bailing out");return}let r=e.nodes(),o=!1;for(let a of r){let d=e.children(a);o||(o=d.length>0)}if(!o){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",r,n);for(let a of r)if(i.debug("Extracting node",a,c,c.has(a)&&!c.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",n),!c.has(a))i.debug("Not a cluster",a,n);else if(!c.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,n);let d=e.graph().rankdir==="TB"?"LR":"TB";(s=(l=c.get(a))==null?void 0:l.clusterData)!=null&&s.dir&&(d=c.get(a).clusterData.dir,i.warn("Fixing dir",c.get(a).clusterData.dir,d));let p=new O({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",X(e)),P(a,e,p,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:c.get(a).clusterData,label:c.get(a).label,graph:p}),i.warn("New graph after copy node: (",a,")",X(p)),i.debug("Old graph after copy",X(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!c.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),n),i.debug(c);r=e.nodes(),i.warn("New list of nodes",r);for(let a of r){let d=e.node(a);i.warn(" Now next level",a,d),d!=null&&d.clusterNode&&A(d.graph,n+1)}},"extractor"),J=w((e,n)=>{if(n.length===0)return[];let r=Object.assign([],n);return n.forEach(o=>{let l=e.children(o),s=J(e,l);r=[...r,...s]}),r},"sorter"),ae=w(e=>J(e,e.children()),"sortNodesByHierarchy"),R=w(async(e,n,r,o,l,s)=>{i.warn("Graph in recursive render:XAX",X(n),l);let a=n.graph().rankdir;i.trace("Dir in recursive render - dir:",a);let d=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));let p=d.insert("g").attr("class","clusters"),E=d.insert("g").attr("class","edgePaths"),N=d.insert("g").attr("class","edgeLabels"),f=d.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(g){let t=n.node(g);if(l!==void 0){let u=JSON.parse(JSON.stringify(l.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,u.height,`
Parent cluster`,l.height),n.setNode(l.id,u),n.parent(g)||(i.trace("Setting parent",g,l.id),n.setParent(g,l.id,u))}if(i.info("(Insert) Node XXX"+g+": "+JSON.stringify(n.node(g))),t==null?void 0:t.clusterNode){i.info("Cluster identified XBX",g,t.width,n.node(g));let{ranksep:u,nodesep:m}=n.graph();t.graph.setGraph({...t.graph.graph(),ranksep:u+25,nodesep:m});let v=await R(f,t.graph,r,o,n.node(g),s),C=v.elem;K(t,C),t.diff=v.diff||0,i.info("New compound node after recursive render XAX",g,"width",t.width,"height",t.height),_(C,t)}else n.children(g).length>0?(i.trace("Cluster - the non recursive path XBX",g,t.id,t,t.width,"Graph:",n),i.trace(x(t.id,n)),c.set(t.id,{id:x(t.id,n),node:t})):(i.trace("Node - the non recursive path XAX",g,f,n.node(g),a),await Y(f,n.node(g),{config:s,dir:a}))})),await w(async()=>{let g=n.edges().map(async function(t){let u=n.edge(t.v,t.w,t.name);i.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(n.edge(t))),i.info("Fix",c,"ids:",t.v,t.w,"Translating: ",c.get(t.v),c.get(t.w)),await W(N,u)});await Promise.all(g)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(X(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),L(n),i.info("Graph after layout:",JSON.stringify(X(n)));let h=0,{subGraphTitleTotalMargin:y}=j(s);return await Promise.all(ae(n).map(async function(g){var u;let t=n.node(g);if(i.info("Position XBX => "+g+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=y,i.info("A tainted cluster node XBX1",g,t.id,t.width,t.height,t.x,t.y,n.parent(g)),c.get(t.id).node=t,k(t);else if(n.children(g).length>0){i.info("A pure cluster node XBX1",g,t.id,t.x,t.y,t.width,t.height,n.parent(g)),t.height+=y,n.node(t.parentId);let m=(t==null?void 0:t.padding)/2||0,v=((u=t==null?void 0:t.labelBBox)==null?void 0:u.height)||0,C=v-m||0;i.debug("OffsetY",C,"labelHeight",v,"halfPadding",m),await H(p,t),c.get(t.id).node=t}else{let m=n.node(t.parentId);t.y+=y/2,i.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",m,m==null?void 0:m.offsetY,t),k(t)}})),n.edges().forEach(function(g){let t=n.edge(g);i.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(t),t),t.points.forEach(C=>C.y+=y/2);let u=n.node(g.v);var m=n.node(g.w);let v=V(E,t,c,r,u,m,o);Q(t,v)}),n.nodes().forEach(function(g){let t=n.node(g);i.info(g,t.type,t.diff),t.isGroup&&(h=t.diff)}),i.warn("Returning from recursive render XAX",d,h),{elem:d,diff:h}},"recursiveRender"),oe=w(async(e,n)=>{var s,a,d,p,E,N;let r=new O({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((d=(a=e.config)==null?void 0:a.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((N=(E=e.config)==null?void 0:E.flowchart)==null?void 0:N.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=n.select("g");U(o,e.markers,e.type,e.diagramId),z(),Z(),q(),re(),e.nodes.forEach(f=>{r.setNode(f.id,{...f}),f.parentId&&r.setParent(f.id,f.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(f=>{if(f.start===f.end){let h=f.start,y=h+"---"+h+"---1",g=h+"---"+h+"---2",t=r.node(h);r.setNode(y,{domId:y,id:y,parentId:t.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),r.setParent(y,t.parentId),r.setNode(g,{domId:g,id:g,parentId:t.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),r.setParent(g,t.parentId);let u=structuredClone(f),m=structuredClone(f),v=structuredClone(f);u.label="",u.arrowTypeEnd="none",u.id=h+"-cyclic-special-1",m.arrowTypeStart="none",m.arrowTypeEnd="none",m.id=h+"-cyclic-special-mid",v.label="",t.isGroup&&(u.fromCluster=h,v.toCluster=h),v.id=h+"-cyclic-special-2",v.arrowTypeStart="none",r.setEdge(h,y,u,h+"-cyclic-special-0"),r.setEdge(y,g,m,h+"-cyclic-special-1"),r.setEdge(g,h,v,h+"-cyc<lic-special-2")}else r.setEdge(f.start,f.end,{...f},f.id)}),i.warn("Graph at first:",JSON.stringify(X(r))),ie(r),i.warn("Graph after XAX:",JSON.stringify(X(r)));let l=M();await R(o,r,e.type,e.diagramId,void 0,l)},"render");export{oe as render};
