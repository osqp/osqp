import{_ as m,ad as M,ae as j,af as L,ag as Y,l as i,c as H,ah as _,ai as $,a0 as q,a5 as z,a1 as O,$ as K,aj as Q,ak as U,al as V}from"./mermaid-D59lkToe.js";import{G as k}from"./graph-CQvdQbxU.js";import{l as W}from"./layout-DuQ9W6pS.js";import{i as x}from"./_baseUniq-CGK6su7v.js";import{c as Z}from"./clone-DFaYgbfI.js";import{m as G}from"./min-DrLfF3uL.js";import"./index-D4bXoNM3.js";import"./transform-B8bpuzxV.js";import"./timer-BwIYMJWC.js";import"./step-BwsUM5iJ.js";import"./_baseEach-CIMlsWNn.js";import"./sortBy-utaS96Bi.js";import"./_baseMap-1GEe_WcR.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:te(e)};return x(e.graph())||(r.value=Z(e.graph())),r}function ee(e){return G(e.nodes(),function(r){var t=e.node(r),o=e.parent(r),d={v:r};return x(t)||(d.value=t),x(o)||(d.parent=o),d})}function te(e){return G(e.edges(),function(r){var t=e.edge(r),o={v:r.v,w:r.w};return x(r.name)||(o.name=r.name),x(t)||(o.value=t),o})}var l=new Map,b=new Map,P=new Map,re=m(()=>{b.clear(),P.clear(),l.clear()},"clear"),D=m((e,r)=>{const t=b.get(r)||[];return i.trace("In isDescendant",r," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ne=m((e,r)=>{const t=b.get(r)||[];return i.info("Descendants of ",r," is ",t),i.info("Edge is ",e),e.v!==r&&e.w!==r&&(t?t.includes(e.v)||D(e.v,r)||D(e.w,r)||t.includes(e.w):(i.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),B=m((e,r,t,o)=>{i.warn("Copying children of ",e,"root",o,"data",r.node(e),o);const d=r.children(e)||[];e!==o&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(s=>{if(r.children(s).length>0)B(s,r,t,o);else{const a=r.node(s);i.info("cp ",s," to ",o," with parent ",e),t.setNode(s,a),o!==r.parent(s)&&(i.warn("Setting parent",s,r.parent(s)),t.setParent(s,r.parent(s))),e!==o&&s!==e?(i.debug("Setting parent",s,e),t.setParent(s,e)):(i.info("In copy ",e,"root",o,"data",r.node(e),o),i.debug("Not Setting parent for node=",s,"cluster!==rootId",e!==o,"node!==clusterId",s!==e));const c=r.edges(s);i.debug("Copying Edges",c),c.forEach(f=>{i.info("Edge",f);const E=r.edge(f.v,f.w,f.name);i.info("Edge data",E,o);try{ne(f,o)?(i.info("Copying as ",f.v,f.w,E,f.name),t.setEdge(f.v,f.w,E,f.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",o," clusterId:",e)}catch(C){i.error(C)}})}i.debug("Removing node",s),r.removeNode(s)})},"copy"),J=m((e,r)=>{const t=r.children(e);let o=[...t];for(const d of t)P.set(d,e),o=[...o,...J(d,r)];return o},"extractDescendants"),ie=m((e,r,t)=>{const o=e.edges().filter(c=>c.v===r||c.w===r),d=e.edges().filter(c=>c.v===t||c.w===t),s=o.map(c=>({v:c.v===r?t:c.v,w:c.w===r?r:c.w})),a=d.map(c=>({v:c.v,w:c.w}));return s.filter(c=>a.some(f=>c.v===f.v&&c.w===f.w))},"findCommonEdges"),I=m((e,r,t)=>{const o=r.children(e);if(i.trace("Searching children of id ",e,o),o.length<1)return e;let d;for(const s of o){const a=I(s,r,t),c=ie(r,t,a);if(a){if(!(c.length>0))return a;d=a}}return d},"findNonClusterChild"),A=m(e=>l.has(e)&&l.get(e).externalConnections&&l.has(e)?l.get(e).id:e,"getAnchorId"),ae=m((e,r)=>{if(!e||r>10)i.debug("Opting out, no graph ");else{i.debug("Opting in, graph "),e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",I(t,e,t)),b.set(t,J(t,e)),l.set(t,{id:I(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const o=e.children(t),d=e.edges();o.length>0?(i.debug("Cluster identified",t,b),d.forEach(s=>{D(s.v,t)^D(s.w,t)&&(i.warn("Edge: ",s," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",b.get(t)),l.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,b)});for(let t of l.keys()){const o=l.get(t).id,d=e.parent(o);d!==t&&l.has(d)&&!l.get(d).externalConnections&&(l.get(t).id=d)}e.edges().forEach(function(t){const o=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let d=t.v,s=t.w;if(i.warn("Fix XXX",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v)," --- ",l.get(t.w)),l.get(t.v)||l.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),d=A(t.v),s=A(t.w),e.removeEdge(t.v,t.w,t.name),d!==t.v){const a=e.parent(d);l.get(a).externalConnections=!0,o.fromCluster=t.v}if(s!==t.w){const a=e.parent(s);l.get(a).externalConnections=!0,o.toCluster=t.w}i.warn("Fix Replacing with XXX",d,s,t.name),e.setEdge(d,s,o,t.name)}}),i.warn("Adjusted Graph",X(e)),T(e,0),i.trace(l)}},"adjustClustersAndEdges"),T=m((e,r)=>{var d,s;if(i.warn("extractor - ",r,X(e),e.children("D")),r>10)return void i.error("Bailing out");let t=e.nodes(),o=!1;for(const a of t){const c=e.children(a);o=o||c.length>0}if(o){i.debug("Nodes = ",t,r);for(const a of t)if(i.debug("Extracting node",a,l,l.has(a)&&!l.get(a).externalConnections,!e.parent(a),e.node(a),e.children("D")," Depth ",r),l.has(a))if(!l.get(a).externalConnections&&e.children(a)&&e.children(a).length>0){i.warn("Cluster without external connections, without a parent and with children",a,r);let c=e.graph().rankdir==="TB"?"LR":"TB";(s=(d=l.get(a))==null?void 0:d.clusterData)!=null&&s.dir&&(c=l.get(a).clusterData.dir,i.warn("Fixing dir",l.get(a).clusterData.dir,c));const f=new k({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",X(e)),B(a,e,f,a),e.setNode(a,{clusterNode:!0,id:a,clusterData:l.get(a).clusterData,label:l.get(a).label,graph:f}),i.warn("New graph after copy node: (",a,")",X(f)),i.debug("Old graph after copy",X(e))}else i.warn("Cluster ** ",a," **not meeting the criteria !externalConnections:",!l.get(a).externalConnections," no parent: ",!e.parent(a)," children ",e.children(a)&&e.children(a).length>0,e.children("D"),r),i.debug(l);else i.debug("Not a cluster",a,r);t=e.nodes(),i.warn("New list of nodes",t);for(const a of t){const c=e.node(a);i.warn(" Now next level",a,c),c!=null&&c.clusterNode&&T(c.graph,r+1)}}else i.debug("Done, no node has children",e.nodes())},"extractor"),R=m((e,r)=>{if(r.length===0)return[];let t=Object.assign([],r);return r.forEach(o=>{const d=e.children(o),s=R(e,d);t=[...t,...s]}),t},"sorter"),oe=m(e=>R(e,e.children()),"sortNodesByHierarchy"),F=m(async(e,r,t,o,d,s)=>{i.warn("Graph in recursive render:XAX",X(r),d);const a=r.graph().rankdir;i.trace("Dir in recursive render - dir:",a);const c=e.insert("g").attr("class","root");r.nodes()?i.info("Recursive render XXX",r.nodes()):i.info("No nodes found for",r),r.edges().length>0&&i.info("Recursive edges",r.edge(r.edges()[0]));const f=c.insert("g").attr("class","clusters"),E=c.insert("g").attr("class","edgePaths"),C=c.insert("g").attr("class","edgeLabels"),p=c.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){const n=r.node(g);if(d!==void 0){const h=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,h.height,`
Parent cluster`,d.height),r.setNode(d.id,h),r.parent(g)||(i.trace("Setting parent",g,d.id),r.setParent(g,d.id,h))}if(i.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),n==null?void 0:n.clusterNode){i.info("Cluster identified XBX",g,n.width,r.node(g));const{ranksep:h,nodesep:u}=r.graph();n.graph.setGraph({...n.graph.graph(),ranksep:h+25,nodesep:u});const N=await F(p,n.graph,t,o,r.node(g),s),S=N.elem;_(n,S),n.diff=N.diff||0,i.info("New compound node after recursive render XAX",g,"width",n.width,"height",n.height),$(S,n)}else r.children(g).length>0?(i.trace("Cluster - the non recursive path XBX",g,n.id,n,n.width,"Graph:",r),i.trace(I(n.id,r)),l.set(n.id,{id:I(n.id,r),node:n})):(i.trace("Node - the non recursive path XAX",g,p,r.node(g),a),await q(p,r.node(g),{config:s,dir:a}))})),await m(async()=>{const g=r.edges().map(async function(n){const h=r.edge(n.v,n.w,n.name);i.info("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.info("Edge "+n.v+" -> "+n.w+": ",n," ",JSON.stringify(r.edge(n))),i.info("Fix",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v),l.get(n.w)),await V(C,h)});await Promise.all(g)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(X(r))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),W(r),i.info("Graph after layout:",JSON.stringify(X(r)));let y=0,{subGraphTitleTotalMargin:v}=z(s);return await Promise.all(oe(r).map(async function(g){var h;const n=r.node(g);if(i.info("Position XBX => "+g+": ("+n.x,","+n.y,") width: ",n.width," height: ",n.height),n==null?void 0:n.clusterNode)n.y+=v,i.info("A tainted cluster node XBX1",g,n.id,n.width,n.height,n.x,n.y,r.parent(g)),l.get(n.id).node=n,O(n);else if(r.children(g).length>0){i.info("A pure cluster node XBX1",g,n.id,n.x,n.y,n.width,n.height,r.parent(g)),n.height+=v,r.node(n.parentId);const u=(n==null?void 0:n.padding)/2||0,N=((h=n==null?void 0:n.labelBBox)==null?void 0:h.height)||0,S=N-u||0;i.debug("OffsetY",S,"labelHeight",N,"halfPadding",u),await K(f,n),l.get(n.id).node=n}else{const u=r.node(n.parentId);n.y+=v/2,i.info("A regular node XBX1 - using the padding",n.id,"parent",n.parentId,n.width,n.height,n.x,n.y,"offsetY",n.offsetY,"parent",u,u==null?void 0:u.offsetY,n),O(n)}})),r.edges().forEach(function(g){const n=r.edge(g);i.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(n),n),n.points.forEach(S=>S.y+=v/2);const h=r.node(g.v);var u=r.node(g.w);const N=Q(E,n,l,t,h,u,o);U(n,N)}),r.nodes().forEach(function(g){const n=r.node(g);i.info(g,n.type,n.diff),n.isGroup&&(y=n.diff)}),i.warn("Returning from recursive render XAX",c,y),{elem:c,diff:y}},"recursiveRender"),se=m(async(e,r)=>{var s,a,c,f,E,C;const t=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((s=e.config)==null?void 0:s.nodeSpacing)||((c=(a=e.config)==null?void 0:a.flowchart)==null?void 0:c.nodeSpacing)||e.nodeSpacing,ranksep:((f=e.config)==null?void 0:f.rankSpacing)||((C=(E=e.config)==null?void 0:E.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=r.select("g");M(o,e.markers,e.type,e.diagramId),j(),L(),Y(),re(),e.nodes.forEach(p=>{t.setNode(p.id,{...p}),p.parentId&&t.setParent(p.id,p.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(p=>{if(p.start===p.end){const w=p.start,y=w+"---"+w+"---1",v=w+"---"+w+"---2",g=t.node(w);t.setNode(y,{domId:y,id:y,parentId:g.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),t.setParent(y,g.parentId),t.setNode(v,{domId:v,id:v,parentId:g.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),t.setParent(v,g.parentId);const n=structuredClone(p),h=structuredClone(p),u=structuredClone(p);n.label="",n.arrowTypeEnd="none",n.id=w+"-cyclic-special-1",h.arrowTypeStart="none",h.arrowTypeEnd="none",h.id=w+"-cyclic-special-mid",u.label="",g.isGroup&&(n.fromCluster=w,u.toCluster=w),u.id=w+"-cyclic-special-2",u.arrowTypeStart="none",t.setEdge(w,y,n,w+"-cyclic-special-0"),t.setEdge(y,v,h,w+"-cyclic-special-1"),t.setEdge(v,w,u,w+"-cyc<lic-special-2")}else t.setEdge(p.start,p.end,{...p},p.id)}),i.warn("Graph at first:",JSON.stringify(X(t))),ae(t),i.warn("Graph after XAX:",JSON.stringify(X(t)));const d=H();await F(o,t,e.type,e.diagramId,void 0,d)},"render");export{se as render};
